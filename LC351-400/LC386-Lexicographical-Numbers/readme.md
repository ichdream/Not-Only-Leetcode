## 题目描述

给定一个整数 n, 返回从 1 到 n 的字典顺序。

例如，给定 n =13，返回 [1,10,11,12,13,2,3,4,5,6,7,8,9] 。

请尽可能的优化算法的时间复杂度和空间复杂度。 输入的数据 n 小于等于 5,000,000。

> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/lexicographical-numbers
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

## 题目多角度分析

### 审题

题目描述非常简单，以至于一开始没有读了几遍题目，没有明白题目到底想让做什么，例子也只有一个。

那么，这个时候只有仔细审题了。理解这道题需要有相关的知识储备：**字典序**。

字典序是用于一系列字符串之间排序的规则，两个字符串之间按照字典序进行比较，是指：将两个字符串以头对齐后，从前往后逐个比较两个字符串中同一位置字符的大小，字符的大小规则按照它们在英文字典中出现的先后顺序进行定义。如果两个字符串长度不想等，那么在遍历短的字符串后，如果此前比较的所有字符，二者都想等， 短的字符串对应的字典序获得较小值。

> 例如：
>
> 字符串"leetcode", "leet"
>
> leetcode
>
> leet
>
> leet字典序 < leetcode字典序

这道题，将字典序的定义搬迁到整数上，整数的每一位上的数字对应字符串上的单个字符，排序规则不变。

再结合例子，前面的猜想就得到验证。



### 难度

中等



### 出现频率

低频



### 题目来源

- 最初来源未知

- 只见到小马智行，字节跳动偶尔考察过。



### 题目想考察什么？🤔

- 排序
- 数组
- 递归
- 栈

codes目录给出了四种不同的解法：

1 最朴素的解法应该是排序，自定义排序规则，对应版本v2;

2 按照数据的生成规则采用深度优先遍历的方式，对应于v1

3 递归和循环可以互换，那么v2的非递归版本，基于栈可以实现，对应v4

4 数字规律法，按照数字的生成规律，不采用辅助栈，对应版本v3



###  题目评价

个人👤认为这不是一个质量较高的题目，题目看起来不难，很简洁，有很多思路可以解决。

缺点：

题目描述不清，不严谨，太过简单，例子只有一个，没有辅助解释说明。



### 类似题目索引

