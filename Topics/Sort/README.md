## 排序算法

### 概述

为什么排序如此重要？

### 分类

按照是否使用内存来分类，可划分为：

- 内排序
- 外排序

按照排序过程中是否需要元素间比较：

- 基于元素间比较的排序：

- 不需要元素间比较排序：



#### 快速排序

- 选择一个pivot，将数组中所有小于pivot所指值的元素都放置到pivot的左边，将所有大于pivot所指值的右边。

- 对pivot左边的子数组重复上述操作，知道数组中元素个数为1

- 对pivot右边的子数组重复上述操作，直到数组中元素个数为1

快速排序对数据的分布比较敏感，由于采用分治思想，每次通过pivot将数据分为两份，对于如果把pivot左右两边分别看成一个整体，用pivotL和pivotR表示，那么pivotL, pivot, pivotR三项可以看成是排好序列的。接下来的步骤只需要分别对pivotL和pivotR分别进行同样的操作即可，直到pivotL和pivotR只有一个元素为止。

所以，需要多少次拆分影响整体的时间效率，如果数据均衡分布，可以发现拆分次数接近log(n), n为原始数组中元素个数。如果原始数据基本有序，可以发现拆分次数接近n。

所以，为了提升算法的效率，应该在每次通过pivot拆分数据时，应使得拆分后两部分数据量尽可能想等。那么，有哪些因素影响这个呢？

- Pivot的值

  这个比较容易想到，但每次在选pivot前，我们并不知道怎么选择pivot才能使得拆分后，两部分的数据量接近。根据数学性质，中位数可以，但获取一个数组中的中位数，复杂度是O(n)，除非这个数组已经排好序，复杂度太高，这个思路不行🙅‍♂️。随机选择一个pivot的做法被实践证明效率还不错，比较具有可行性。另外一个做法是，随机选择三个值，取三个值中的中位数，这个是抽样近似的方法。

- 等于Pivot的元素怎么划分

  真实的环境中，这个很常见，按照上面优化的思路，应该是将等于pivot的元素均匀的分给左右两部分。

 注意事项⚠️：

